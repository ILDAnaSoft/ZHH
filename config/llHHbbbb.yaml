# Steering file for cutflow.py
# 2025/11/05 - Bryan Bliewert / DESY / bryan.bliewert@desy.de

# Changes:
# 2025/11: following globals are allowed: EventCategories, FinalStateDefinitions
#          following environment variables are assumed: REPO_ROOT, DATA_PATH

hypothesis: μμbbbb
signal_categories:
- EventCategories.μμHHbbbb
- EventCategories.llhh_llnonbbbb

# used to calculate event weights and absolute event counts
# polarization of [ electronBeam, positronBeam ]
beam_polarization: [ -0.8, +0.3 ]

# unit: ab^-1
luminosity: 2.

# set to true for a clean run; i.e. delete previous run through cutflow (plots/tables),
# MVA training files + any plots/tables. can also be set individually per source in the
# sources section below
reset: false

# use automatic caching for faster data access. if True, reads data once from ROOT TTrees
# and writes into a HDF5 (feature data, I/O much faster than uproot) and npz (metadata)
# file. see the path option in the sources section. may require a few GB.
# info: this also saves event category data. if you add/change the categorization, you
# need to clear the cache by setting reset to true for the respective source.
use_caching: true

# definition of event categories
# the registration of event categories to specific sources is done in the sources section
# info: while the naming can be arbitrary, a unique ID must be supplied which must exist 
#       in the EVENT_CATEGORIES_TRUE class, too. See EventCategories.py
event_categories: '$REPO_ROOT/config/event_categories.yaml'

# definition of input data and information about the event categorization
# path                : path to a directory containing Merged.root file whose content
#                       must be compliant to the one output from the AnalysisCombine
#                       workflow task. if use_caching=True, the directory must be wri-
#                       table to store the cache files
# event_categorization: items: the categories to register for the respective source
#                       default: optional default category to apply first
#                       order: optional, will use the order used in items if null or
#                              not apply any category beyond the default one if []
#                       
#                       for configuring the items for event_categorization, see
#                         config/event_categories.yaml
# file                : optional, default: Merged.root; ROOT file with EventObservables*,
#                       KinFit*, FinalStates TTrees etc.
sources:
  - name: 4fsl
    path: $DATA_PATH/AnalysisCombine/550-4fsl-$CONF_SUFFIX
    root_files: $DATA_PATH/AnalysisFinal/550-4fsl-$CONF_SUFFIX/*.root
    event_categorization:
      default: EventCategories.F4_OTHER
      order: null
      items: [ eebb, μμbb, ττbb, lvqq ]
    disabled: false
    reset: false

  - name: 2l4q
    path: $DATA_PATH/AnalysisCombine/550-2l4q-$CONF_SUFFIX
    root_files: $DATA_PATH/AnalysisFinal/550-2l4q-$CONF_SUFFIX/*.root
    event_categorization:
      default: EventCategories.F6_OTHER
      order: null
      items: [ lvqqqq, lvbbqq, evbbqq, μvbbqq, τvbbqq, lvbbbb, llqqqq, llbbqq, llbbbb, vvqqqq, vvbbqq ]
    disabled: false
    reset: false

  - name: llhh
    path: $DATA_PATH/AnalysisCombine/550-llhh-$CONF_SUFFIX
    root_files: $DATA_PATH/AnalysisFinal/550-llhh-$CONF_SUFFIX/*.root
    event_categorization:
      default: null
      order: null
      items: [ llhh, eeHHbbbb, μμHHbbbb, ττHHbbbb, llhh_llbbbb, llhh_llnonbbbb, llqqh ]
    disabled: false
    reset: false

  - name: 6q
    path: $DATA_PATH/AnalysisCombine/550-6q-$CONF_SUFFIX
    root_files: $DATA_PATH/AnalysisFinal/550-6q-$CONF_SUFFIX/*.root
    event_categorization:
      default: EventCategories.qqqqqq
      order: []
      items: [ bbqqqq, bbbbqq, bbbbbb ]
    disabled: false
    reset: false

  - name: tthz
    path: $DATA_PATH/AnalysisCombine/550-tthz-$CONF_SUFFIX
    root_files: $DATA_PATH/AnalysisFinal/550-tthz-$CONF_SUFFIX/*.root
    event_categorization:
      default: EventCategories.ttHZ
      order: null
      items: [ ttH, ttZ, ttHZ ]
    disabled: true
    reset: false

# feature definition
# controls how data from ROOT input files of each source should be interpreted and
# converted to columnar format. assumes that branches are in regular shape, i.e.
# have same number of rows (and also columns for 2D branches)
features:

  # interpret a branch of a TTree as either 1D or 2D array, supports 1D+2D branches
  # all properties defined here will be readonly in analysis code
  # Arguments:
  # interpret/name: name of output dataset in HDF5 file. data is accessed using this key
  #                 as hdf5file[name] or dataStore[name] in analysis code. see also names
  # interpret/tree: TTree and name
  # interpret/branch: (optional) branch name; name will be used, if not provided
  # interpret/columns: for 2D arrays: must be an integer, specifying how many columns are
  #                    expected to exist they will be saved as <name>.dim<i> with i=0,..,
  #                    <columns>
  #                    for named arrays: must be a list of strings, specifying the names
  #                    of each column (e.g. fCoordinates.fX, ... for a PxPyPzE vector)
  # interpret/auto_increment: if True, this will be filled with np.arange(nrows, [dtype=
  #                           interpret/dtype, defaults to uint32])
  # interpret/names: list of names; can be used to create multiple entries within the
  #                  interpret section with different name. this enforces branch = name
  # interpret/clamp_min or clamp_max: if defined, values of this branch will be clamped
  #                                   within this range
  # interpret/nan_to: if defined, NaN values will be replaced with this. this is done 
  #                   after clamping (if any)
  interpret:
  - { name: id, dtype: uint32, auto_increment: true }
  - { name: event, tree: FinalStates, dtype: uint32 }
  #- { name: event_category, tree: FinalStates, dtype: uint8 }
  - { name: cross_section, tree: FinalStates, dtype: float }
  #- { name: pid, tree: FinalStates, branch: process_id, dtype: uint16 }
  - { name: final_state_counts, tree: FinalStates, branch: final_state_counts.second, columns: 17, dtype: uint8 }
  - { name: n_b_from_higgs, tree: FinalStates, dtype: uint8 }
  - { name: pol_code, tree: FinalStates, branch: polarization_code, dtype: uint8 }
  - { name: process, tree: FinalStates, dtype: uint32 }

  # physics quantities; must be given because some other quantities use this
  - { name: cosjzmax, tree: EventObservablesLL, branch: cosJZMax_2Jets, dtype: float32 }

  # physics quantities
  - { names: [ bmax1, bmax2, bmax3, bmax4 ], tree: EventObservablesLL, dtype: float32 }
  - { names: [ jet1_m, jet2_m, jet3_m, jet4_m ], tree: EventObservablesLL, dtype: float32 }
  - { name: mz_pre_pairing, tree: EventObservablesLL, branch: mzll_pre_pairing, dtype: float32 }
  - { name: mhh, tree: EventObservablesLL, branch: m_invjet, dtype: float32 }
  - { names: [ fit4C_mz, ptmiss, thrust, evis ], tree: EventObservablesLL, dtype: float32 }
  - { name: fit4C_mh1, tree: EventObservablesLL, dtype: float32, nan_to: -20., clamp_min: -10. }
  - { name: fit4C_mh2, tree: EventObservablesLL, dtype: float32, nan_to: -20., clamp_min: -10. }
  - { names: [ nisomuons, pairedLepType ], tree: EventObservablesLL, dtype: uint8 }
  
  # for MVA analysis
  - { names: [ npfos ], tree: EventObservablesLL, dtype: uint16 }
  - { names: [ costhrust, pjmax2, npfosmin4j, yplus, plmin, mbmax12, mbmax34,
               mvalepminus, yminus2 ], tree: EventObservablesLL, dtype: float32 } # mcmax12, mcmax34,
  - { name: ZHH_FitChi2, tree: KinFitLL_ZHH, branch: FitChi2, dtype: float32 }
  - { name: ZZH_FitChi2, tree: KinFitLL_ZZH, branch: FitChi2, dtype: float32 }
  - { name: ZHH_p1stBeforeFit, tree: KinFitLL_ZHH, branch: p1stBeforeFit, dtype: float32 }
  - { name: ZZH_p1stBeforeFit, tree: KinFitLL_ZZH, branch: p1stBeforeFit, dtype: float32 }
  - { name: ZHH_cosThBeforeFit, tree: KinFitLL_ZHH, branch: cosThBeforeFit, dtype: float32 }
  - { name: ZZH_cosThBeforeFit, tree: KinFitLL_ZZH, branch: cosThBeforeFit, dtype: float32 }

  # MEM
  - { names: [
        lep1_4v/fCoordinates,
        lep2_4v/fCoordinates,
        jet1_4v/fCoordinates,
        jet2_4v/fCoordinates,
        jet3_4v/fCoordinates,
        jet4_4v/fCoordinates
      ], tree: EventObservablesLL, dtype: float32, columns: [ fCoordinates.fX, fCoordinates.fY, fCoordinates.fZ, fCoordinates.fT ] }
  - { name: jet_matching_kinfit_best, tree: EventObservablesLL, dtype: int8, columns: 4 }
  - { names: [ jet1_tags, jet2_tags, jet3_tags, jet4_tags ], tree: EventObservablesLL, dtype: float32 }
  
  # TODO: ability to use custom handlers to attach these
  # serialize:
  # - { handler: Serializers.JetMasses, provides: [ jet0_m, jet1_m, jet2_m, jet4_m ] }

# cutflow_table
# defines the event categories and the order with which they should be appear in the
# cutflow table and also which of them are considered to belong to the signal (these
# are appended to the rightmost part of the table).
# items/category: name of the event category (must be part of EventCategories)
# items/label: column label (supports LaTeX)
# items/is_signal: optional, defaults to false; whether or not this category belongs to
#                  the signal
# ignore_categories: for each background category A that includes another category B,
#                    category B must be given here to avoid double counting

cutflow_table:
  items:
    - category: μμbb
      label: '\boldsymbol{\mu\mu} bb'
    - category: μvbbqq
      label: '\boldsymbol{\mu \nu b b q q}'
    - category: bbqqqq
      label: bbqqqq
    - category: llqqqq
      label: llqqqq
    - category: llbbbb
      label: (llbbbb)
    - category: llqqh
      label: llqqh
    - category: llhh
      label: llhh
      is_signal: true
    - category: μμHHbbbb
      label: (\mu\mu bbbb)
      is_signal: true
  ignore_categories: llbbbb

# general note about cuts:
# they appear in groups composed of at least one cut and are denoted in code by the
# parameter 'step'
# the first group is preselection (group/step=0). <counter> starts at 0 too
# every stage of MVA will add another group (1,2,3 etc.)
# future TODO: assig an ID to cuts as in cut.<group>.<counter>

# parameters:
# cuts.<group>.quantity: (name in data store/ROOT TTree), operator (see below),
#                             value or lower+upper, label (description to use in plots) 
# cuts.<group>.operator: any of gte (greater than or equal), lte (lower than or
#                             eqal), eq (equal) or within_bounds
# cuts.<group>.{value/lower/upper}: cut parameters
#
# all parameters (except of operator) are passed directly to the respective constructors
# of Less/GreaterThan/Equal/WithinBoundsCut cuts can be disabled by commenting out the
# line or adding disabled: true

cuts:
  preselection:
  - { quantity: nisomuons, operator: gte, value: 2, label: IsoMuons }
  - { quantity: pairedLepType, operator: eq, value: 13, label: Paired Lepton Type }
  - { quantity: fit4C_mz, operator: within_bounds, lower: 20., upper: 150., label: 'm_{ll}^{4C}', unit: 'GeV', xlim_view: [0, 270] }
  - { quantity: fit4C_mh1, operator: within_bounds, lower: 50., upper: 200., label: 'm_{H1}^{4C}', unit: 'GeV', xlim_view: [0, 500] }
  - { quantity: fit4C_mh2, operator: within_bounds, lower: 50., upper: 200., label: 'm_{H2}^{4C}', unit: 'GeV', xlim_view: [0, 550] }
  - { quantity: ptmiss, operator: lte, value: 70., label: 'p_{t}^{miss}', unit: 'GeV' }
  - { quantity: thrust, operator: lte, value: 0.9, label: 'thrust' }
  - { quantity: sumBTags, operator: gte, value: 1., label: 'sum b-tags', disabled: true }
  
  mva_cut:
  - { quantity: SigMVAOutput, operator: gte, value: default_mva.threshold }

# MVAs are defined here
# training, inference and optimization (i.e. assignment which threshold value to use) are
# done by actions, which reference the MVA (see the actions section).
# 
#
# parameters:
# mvas.#.name: label/name to reference this MVA in action
# mvas.#.features: list of features (i.e. columns in a DataStore to use)
# mvas.#.classes: list of tuples()
# mvas.#.label_name: column to save the MVA output in
# mvas.#.data_file: file to store input data in
# mvas.#.mva_file: file to save the model to
#
mvas:
  - name: default_mva
    features: [
      jet1_m, jet2_m, jet3_m, jet4_m,
      mhh, fit4C_mz, fit4C_mh1, fit4C_mh2,
      npfos, thrust, costhrust, pjmax2, cosjzmax,
      npfosmin4j, yplus, yminus_mod100, plmin,
      mbmax34, ptmiss, mvalepminus,
      ZHH_FitChi2, ZZH_FitChi2, ZHH_p1stBeforeFit,
      ZZH_p1stBeforeFit, ZHH_cosThBeforeFit, ZZH_cosThBeforeFit,
      bmax1, bmax2, bmax3, bmax4 ]
    classes:
    # two-element arrays of structure (label, name of registered EventCategory)
    # see sources/.../event_categorization/items
    - [0, 'μμHHbbbb']
    - [1, 'llhh_llnonbbbb']
    - [2, 'llqqh']
    - [3, 'llqqqq']
    - [4, 'μμbb']
    - [5, 'lvbbqq']
    # note: the output is the sum for all signal categories given in steer['signal_categories'] 
    label_name: SigMVAOutput

    # file to store the training and testing data in for training this classifier
    data_file: train_test.npz

    mva_file: mva.pickle

# define what should be done after the data is loaded
actions:
  - type: ApplyCuts
    cuts: preselection
    step: 0 # step=0 is always preselection
  
  # optional:
  # step_start: 0
  # step_end: 0
  - type: CreateCutflowPlots
    file: 'cutflow_preselection_plots.pdf'
    
  # optional:
  # step_start: 0
  # step_end: 0
  - type: CreateCutflowTable
    file: 'cutflow_preselection_table.pdf'

  # split in train/testing [accross all steps, i.e. regardless of cut group]
  # creates a new integer column 'split'; for n entries in fractions:
  # value 0 is assigned to a fraction of events specified as first entry in fractions
  # value 1[..]n-1 to fractions given at position 1 to n-1
  # value n is assigned to the remaining events [fraction (1 - sum(all previous values))]
  - type: SplitDatasets
    fractions: [ 0.5 ]
    
  # writes out training/testing data
  # optional:
  # step: 0
  - type: WriteMVAData
    mva: default_mva

  - type: PrintSplitWeights
    disabled: true
  
  # data_source: 'kinfit' or (TODO) 'flavortag' or 'hybrid'
  - type: AttachMatrixElements
    output_name: DsigZHH_ZZH
    data_source: kinfit
    disabled: True

  - type: SklearnMulticlassTraining
    hyperparams: {
      max_depth: 5,
      n_estimators: 250,
      learning_rate: 0.1
    }
    debug: true
    mva: default_mva
    split: 0
    disabled: false

  # optional:
  # clf_prop: clf
  # step: 0
  - type: SklearnMulticlassHyperparamTraining
    hyperparam_bounds: [
      { name: max_depth, type: int, lower: 3, upper: 7 },
      { name: n_estimators, type: int, lower: 250, upper: 750 },
      { name: learning_rate, type: float, lower: 0.01, upper: 0.6 }
    ]
    mva: default_mva
    split: 0
    disabled: true

  # optional:
  # clf_prop: clf
  # step: 0
  - type: SklearnMulticlassInference
    mva: default_mva
    split: 1 # split 0 = train dataset; split 1 = test dataset
    disabled: false
  
  - type: ApplyCuts
    cuts: mva_cut
    step: 1
  
  - type: CreateCutflowPlots
    file: 'cutflow_mva_plots.pdf'
    step_start: 1
    step_end: 1
    
  - type: CreateCutflowTable
    file: 'cutflow_mva_table.pdf'
    step_start: 1
    step_end: 1